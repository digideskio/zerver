package filter

import (
	"net/http"
	"sync"

	"github.com/cosiner/gohper/errors"
	"github.com/cosiner/gohper/net2/http2"
	"github.com/cosiner/gohper/utils/defval"
	"github.com/cosiner/kv"
	log "github.com/cosiner/ygo/jsonlog"
	"github.com/cosiner/zerver"
	"github.com/cosiner/zerver/component"
)

const (
	ErrRequestIDExist = errors.Err("Request id already exist")
)

type (
	// RequestId is a simple filter prevent application/user from overlap request
	// the request id is generated by client itself or other server components.
	RequestId struct {
		Store         IDStore
		HeaderName    string
		PassingOnNoId bool
		Error         string
		ErrorOverlap  string

		log *log.Logger
	}

	IDStore interface {
		zerver.Component
		// if ip-id pair already exist, return ErrRequestIDExist
		Save(id string) error
		Remove(id string) error
	}

	MemIDStore struct {
		requests map[string]struct{} // [ip:id]exist
		lock     sync.RWMutex
	}

	// RedisIDStore depends on component.store
	RedisIDStore struct {
		Key   string // key for redis set to store ip-id pair, default use "RequestID"
		store kv.Store
	}
)

func (m *MemIDStore) Init(zerver.Env) error {
	m.requests = make(map[string]struct{})
	m.lock = sync.RWMutex{}

	return nil
}

func (m *MemIDStore) Destroy() {
	m.requests = nil
}

func (m *MemIDStore) Save(id string) (err error) {
	m.lock.Lock()
	if _, has := m.requests[id]; has {
		err = ErrRequestIDExist
	} else {
		m.requests[id] = struct{}{}

	}
	m.lock.Unlock()

	return
}

func (m *MemIDStore) Remove(id string) error {
	m.lock.Lock()
	delete(m.requests, id)
	m.lock.Unlock()

	return nil
}

func (r *RedisIDStore) Init(env zerver.Env) error {
	rd, err := env.Component(component.REDIS)
	if err != nil {
		return err
	}

	r.store = rd.(kv.Store)
	defval.String(&r.Key, "RequestID")

	return nil
}

func (r *RedisIDStore) Destroy() {
	r.store = nil
}

func (r *RedisIDStore) Save(id string) error {
	cnt, err := r.store.SAdd(r.Key, id)
	if err == nil && cnt == 0 {
		err = ErrRequestIDExist
	}

	return err
}

func (r *RedisIDStore) Remove(ip, id string) error {
	_, err := r.store.SRem(r.Key, id)

	return err
}

func (ri *RequestId) Init(env zerver.Env) error {
	defval.Nil(&ri.Store, new(MemIDStore))
	ri.Store.Init(env)
	defval.String(&ri.HeaderName, "X-Request-Id")
	defval.String(&ri.Error, "header value X-Request-Id can't be empty")
	defval.String(&ri.ErrorOverlap, "request already accepted before, please wait")
	ri.log = log.Derive("Component", "RequestId")
	return nil
}

func (ri *RequestId) Filter(req zerver.Request, resp zerver.Response, chain zerver.FilterChain) {
	if req.ReqMethod() == zerver.METHOD_GET {
		chain(req, resp)
		return
	}

	reqId := req.GetHeader(ri.HeaderName)
	if reqId == "" {
		if ri.PassingOnNoId {
			chain(req, resp)
		} else {
			resp.StatusCode(http.StatusBadRequest)
		}
	} else {
		ip := http2.IpOfAddr(req.RemoteAddr())
		id := ip + ":" + reqId
		if err := ri.Store.Save(id); err == ErrRequestIDExist {
			resp.StatusCode(http.StatusForbidden)
		} else if err != nil {
			ri.log.Warn(log.M{"msg": "save request id failed", "err": err.Error()})
		} else {
			chain(req, resp)
			ri.Store.Remove(id)
		}
	}
}

func (ri *RequestId) Destroy() {}
